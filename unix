!<arch>
colordiff.pl/   1364400864  97975 1054  100751  12865     `
#!/usr/bin/perl -w

########################################################################
#                                                                      #
# ColorDiff - a wrapper/replacment for 'diff' producing                #
#             colourful output                                         #
#                                                                      #
# Copyright (C)2002-2007 Dave Ewart (davee@sungate.co.uk)              #
#                                                                      #
########################################################################
#                                                                      #
# This program is free software; you can redistribute it and/or modify #
# it under the terms of the GNU General Public License as published by #
# the Free Software Foundation; either version 2 of the License, or    #
# (at your option) any later version.                                  #
#                                                                      #
# This program is distributed in the hope that it will be useful,      #
# but WITHOUT ANY WARRANTY; without even the implied warranty of       #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        #
# GNU General Public License for more details.                         #
#                                                                      #
########################################################################

use strict;
#use Getopt::Long qw(:config pass_through);
use IPC::Open3;

my $app_name     = 'colordiff';
my $version      = '1.0.7';
my $author       = 'Dave Ewart';
my $author_email = 'davee@sungate.co.uk';
my $app_www      = 'http://colordiff.sourceforge.net/';
my $copyright    = '(C)2002-2007';
my $show_banner  = 1;
my $color_patch  = 0;

# ANSI sequences for colours
my %colour;
$colour{white}       = "\033[1;37m";
$colour{yellow}      = "\033[1;33m";
$colour{green}       = "\033[1;32m";
$colour{blue}        = "\033[1;34m";
$colour{cyan}        = "\033[1;36m";
$colour{red}         = "\033[1;31m";
$colour{magenta}     = "\033[1;35m";
$colour{black}       = "\033[1;30m";
$colour{darkwhite}   = "\033[0;37m";
$colour{darkyellow}  = "\033[0;33m";
$colour{darkgreen}   = "\033[0;32m";
$colour{darkblue}    = "\033[0;34m";
$colour{darkcyan}    = "\033[0;36m";
$colour{darkred}     = "\033[0;31m";
$colour{darkmagenta} = "\033[0;35m";
$colour{darkblack}   = "\033[0;30m";
$colour{off}         = "\033[0;0m";

# Default colours if /etc/colordiffrc or ~/.colordiffrc do not exist
my $plain_text = $colour{white};
my $file_old   = $colour{red};
my $file_new   = $colour{blue};
my $diff_stuff = $colour{magenta};
my $cvs_stuff  = $colour{green};

# Locations for personal and system-wide colour configurations
my $HOME   = $ENV{HOME};
my $etcdir = '/etc';
my ($setting, $value);
my @config_files = ("$etcdir/colordiffrc");
push (@config_files, "$ENV{HOME}/.colordiffrc") if (defined $ENV{HOME});
my $config_file;

foreach $config_file (@config_files) {
    if (open(COLORDIFFRC, "<$config_file")) {
        while (<COLORDIFFRC>) {
            chop;
            next if (/^#/ || /^$/);
            s/\s+//g;
            ($setting, $value) = split ('=');
            if (!defined $value) {
                print STDERR "Invalid configuration line ($_) in $config_file\n";
                next;
            }
            if ($setting eq 'banner') {
                if ($value eq 'no') {
                    $show_banner = 0;
                }
                next;
            }
            if ($setting eq 'color_patches') {
                if ($value eq 'yes') {
                    $color_patch = 1;
                }
                next;
            }
            $setting =~ tr/A-Z/a-z/;
            $value =~ tr/A-Z/a-z/;
            if (($value eq 'normal') || ($value eq 'none')) {
                $value = 'off';
            }
            if (!defined $colour{$value}) {
                print STDERR "Invalid colour specification for setting $setting ($value) in $config_file\n";
                next;
            }
            if ($setting eq 'plain') {
                $plain_text = $colour{$value};
            }
            elsif ($setting eq 'oldtext') {
                $file_old = $colour{$value};
            }
            elsif ($setting eq 'newtext') {
                $file_new = $colour{$value};
            }
            elsif ($setting eq 'diffstuff') {
                $diff_stuff = $colour{$value};
            }
            elsif ($setting eq 'cvsstuff') {
                $cvs_stuff = $colour{$value};
            }
            else {
                print STDERR "Unknown option in $config_file: $setting\n";
            }
        }
        close COLORDIFFRC;
    }
}

# If output is to a file, switch off colours, unless 'color_patch' is set
# Relates to http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=378563
if ((-f STDOUT) && ($color_patch == 0)) {
    $plain_text='';
    $file_old='';
    $file_new='';
    $diff_stuff='';
    $cvs_stuff='';
    $plain_text='';
    $colour{off}='';
}


# ----------------------------------------------------------------------------
# FIXME
#
# Remove this (contributed) code for now - the long options break the addition
# of extra diff options supplied on the command line.  On balance, modifying the
# diff options is probably more important than having colordiff customisations
# on the command line.
#
# Need to find a proper fix for this so that this can be reincluded

###  GetOptions(
###      "no-banner" => sub { $show_banner = 0 },
###      "plain-text=s" => \&set_color,
###      "file-old=s"   => \&set_color,
###      "file-new=s"   => \&set_color,
###      "cvs-stuff=s"  => \&set_color,
###      "diff-stuff=s" => \&set_color
###  );
# ----------------------------------------------------------------------------

if ($show_banner == 1) {
    print STDERR "$app_name $version ($app_www)\n";
    print STDERR "$copyright $author, $author_email\n\n";
}

my @inputstream;

if (defined $ARGV[0]) {
    # More reliable way of pulling in arguments
   # open2(\*INPUTSTREAM, undef, "diff", @ARGV);
    open3('<&STDIN', \*INPUTSTREAM, '', "diff", @ARGV);
    @inputstream = <INPUTSTREAM>;
    close INPUTSTREAM;
}
else {
    @inputstream = <STDIN>;
}

# Input stream has been read - need to examine it 
# to determine type of diff we have.
#
# This may not be perfect - should identify most reasonably
# formatted diffs and patches

my $diff_type = 'unknown';
my $record;
my $longest_record = 0;

DIFF_TYPE: foreach $record (@inputstream) {
    # Unified diffs are the only flavour having '+++' or '---'
    # at the start of a line
    if ($record =~ /^(\+\+\+|---|@@)/) {
        $diff_type = 'diffu';
        last DIFF_TYPE;
    }
    # Context diffs are the only flavour having '***'
    # at the start of a line
    elsif ($record =~ /^\*\*\*/) {
        $diff_type = 'diffc';
        last DIFF_TYPE;
    }
    # Plain diffs have NcN, NdN and NaN etc.
    elsif ($record =~ /^[0-9,]+[acd][0-9,]+$/) {
        $diff_type = 'diff';
        last DIFF_TYPE;
    }
    # FIXME - This is not very specific, since the regex matches could
    # easily match non-diff output.
    # However, given that we have not yet matched any of the *other* diff
    # types, this might be good enough
    elsif ($record =~ /(\s\|\s|\s<$|\s>\s)/) {
        $diff_type = 'diffy';
        last DIFF_TYPE;
    }
    # wdiff deleted/added patterns
    # should almost always be pairwaise?
    elsif ($record =~ /\[-.*?-\]/s) {
        $diff_type = 'wdiff';
        last DIFF_TYPE;
    }
    elsif ($record =~ /\{\+.*?\+\}/s) {
        $diff_type = 'wdiff';
        last DIFF_TYPE;
    }
}

my $inside_file_old = 1;

# ------------------------------------------------------------------------------
# Special pre-processing for side-by-side diffs
# Figure out location of central markers: these will be a consecutive set of
# three columns where the first and third always consist of spaces and the
# second consists only of spaces, '<', '>' and '|'
# This is not a 100% certain match, but should be good enough

my %separator_col = ();
my %candidate_col = ();
my $diffy_sep_col = 0;
my $mostlikely_sum = 0;

if ($diff_type eq 'diffy') {
    # Not very elegant, but does the job
    # Unfortunately requires parsing the input stream multiple times
    foreach (@inputstream) {
        # Convert tabs to spaces
        while ((my $i = index($_, "\t")) > -1) {
            substr(
                    $_, $i, 1,                # range to replace
                    (' ' x (8 - ($i % 8))),     # string to replace with
                  );
        }
        $record = $_;
        $longest_record = length($record) if (length($record) > $longest_record);
    }
    for(my $i=0;$i <= $longest_record;$i++) {
        $separator_col{$i} = 1;
        $candidate_col{$i} = 0;
    }

    foreach (@inputstream) {
        # Convert tabs to spaces
        while ((my $i = index($_, "\t")) > -1) {
            substr(
                    $_, $i, 1,                # range to replace
                    (' ' x (8 - ($i % 8))),     # string to replace with
                  );
        }
        for(my $i=0;$i<(length($_)-2);$i++) {
            next if (!defined $separator_col{$i});
            next if ($separator_col{$i} == 0);
            my $subsub = substr($_,$i,2);
            if ( ($subsub ne '  ') && ($subsub ne ' |') && ($subsub ne ' >') &&
                    ($subsub ne ' <') ) {
                $separator_col{$i} = 0;
            }
            if (($subsub eq ' |') || ($subsub eq ' >') || ($subsub eq ' <')) {
                $candidate_col{$i}++;
            }
        }
    }

    for(my $i=0;$i<$longest_record-2;$i++) {
        if ($separator_col{$i} == 1) {
            if ($candidate_col{$i} > $mostlikely_sum) {
                $diffy_sep_col = $i;
                $mostlikely_sum = $i;
            }
        }
    }
}
# ------------------------------------------------------------------------------

foreach (@inputstream) {
    if ($diff_type eq 'diff') {
        if (/^</) {
            print "$file_old";
        }
        elsif (/^>/) {
            print "$file_new";
        }
        elsif (/^[0-9]/) {
            print "$diff_stuff";
        }
        elsif (/^(Index: |={4,}|RCS file: |retrieving |diff )/) {
            print "$cvs_stuff";
        }
        else {
            print "$plain_text";
        }
    }
    elsif ($diff_type eq 'diffc') {
        if (/^- /) {
            print "$file_old";
        }
        elsif (/^\+ /) {
            print "$file_new";
        }
        elsif (/^\*{4,}/) {
            print "$diff_stuff";
        }
        elsif (/^\*\*\* [0-9]+,[0-9]+/) {
            print "$diff_stuff";
            $inside_file_old = 1;
        }
        elsif (/^\*\*\* /) {
            print "$file_old";
        }
        elsif (/^--- [0-9]+,[0-9]+/) {
            print "$diff_stuff";
            $inside_file_old = 0;
        }
        elsif (/^--- /) {
            print "$file_new";
        }
        elsif (/^!/) {
            if ($inside_file_old == 1) {
                print "$file_old";
            }
            else {
                print "$file_new";
            }
        }
        elsif (/^(Index: |={4,}|RCS file: |retrieving |diff )/) {
            print "$cvs_stuff";
        }
        else {
            print "$plain_text";
        }
    }
    elsif ($diff_type eq 'diffu') {
        if (/^-/) {
            print "$file_old";
        }
        elsif (/^\+/) {
            print "$file_new";
        }
        elsif (/^\@/) {
            print "$diff_stuff";
        }
        elsif (/^(Index: |={4,}|RCS file: |retrieving |diff )/) {
            print "$cvs_stuff";
        }
        else {
            print "$plain_text";
        }
    }
    # Works with previously-identified column containing the diff-y
    # separator characters
    elsif ($diff_type eq 'diffy') {
        if (length($_) > ($diffy_sep_col+2)) {
            my $sepchars = substr($_, $diffy_sep_col, 2);
            if ($sepchars eq ' <') {
                print "$file_old";
            }
            elsif ($sepchars eq ' |') {
                print "$diff_stuff";
            }
            elsif ($sepchars eq ' >') {
                print "$file_new";
            }
            else {
                print "$plain_text";
            }
        }
        else {
            print "$plain_text";
        }
    }
    elsif ($diff_type eq 'wdiff') {
        $_ =~ s/(\[-[^]]*?-\])/$file_old$1$colour{off}/g;
        $_ =~ s/(\{\+[^]]*?\+\})/$file_new$1$colour{off}/g;
    }
    s/$/$colour{off}/;
    print "$_";
}

#   FIXME - See earlier commented-out code
### sub set_color {
###     my ($type, $color) = @_;
### 
###     $type =~ s/-/_/;
###     eval "\$$type = \$colour{$color}";
### }

colourgcc.pl/   1364400864  97975 1054  100751  6712      `
#! /usr/bin/perl -w

#
# colorgcc
#
# Version: 1.3.2
#
# $Id: colorgcc,v 1.10 1999/04/29 17:15:52 jamoyers Exp $
#
# A wrapper to colorize the output from compilers whose messages
# match the "gcc" format.
#
# Requires the ANSIColor module from CPAN.
#
# Usage:
#
# In a directory that occurs in your PATH _before_ the directory
# where the compiler lives, create a softlink to colorgcc for
# each compiler you want to colorize:
#
#    g++ -> colorgcc
#    gcc -> colorgcc
#    cc  -> colorgcc
#    etc.
#
# That's it. When "g++" is invoked, colorgcc is run instead.
# colorgcc looks at the program name to figure out which compiler to run.
#
# The default settings can be overridden with ~/.colorgccrc.
# See the comments in the sample .colorgccrc for more information.
#
# Note:
#
# colorgcc will only emit color codes if:
# 
#    (1) Its STDOUT is a tty and
#    (2) the value of $TERM is not listed in the "nocolor" option.
#
# If colorgcc colorizes the output, the compiler's STDERR will be
# combined with STDOUT. Otherwise, colorgcc just passes the output from
# the compiler through without modification.
# 
# Author: Jamie Moyers <jmoyers@geeks.com>
# Started: April 20, 1999
# Licence: GNU Public License
#
# Credits:
#
#    I got the idea for this from a script called "color_cvs":
#       color_cvs .03   Adrian Likins <adrian@gimp.org> <adrian@redhat.com>
#
#    <seh4@ix.netcom.com> (Scott Harrington)
#       Much improved handling of compiler command line arguments.
#       exec compiler when not colorizing to preserve STDOUT, STDERR.
#       Fixed my STDIN kludge.
#       
#    <ecarotti@athena.polito.it> (Elias S. G. Carotti)
#       Corrected handling of text like -DPACKAGE=\"Package\"
#       Spotted return code bug.
#
#    <erwin@erwin.andreasen.org> (Erwin S. Andreasen)
#    <schurchi@ucsd.edu> (Steve Churchill)
#       Return code bug fixes.
#
#    <rik@kde.org> (Rik Hemsley)
#       Found STDIN bug.
#
# Changes:
#
# 1.3.2 Better handling of command line arguments to compiler.
#
#       If we aren't colorizing output, we just exec the compiler which
#       preserves the original STDOUT and STDERR.
#
#       Removed STDIN kludge. STDIN being passed correctly now.
# 
# 1.3.1 Added kludge to copy STDIN to the compiler's STDIN.
#
# 1.3.0 Now correctly returns (I hope) the return code of the compiler
#       process as its own.
# 
# 1.2.1 Applied patch to handle text similar to -DPACKAGE=\"Package\".
#
# 1.2.0 Added tty check. If STDOUT is not a tty, don't do color.
#
# 1.1.0 Added the "nocolor" option to turn off the color if the terminal type
#       ($TERM) is listed.
#
# 1.0.0 Initial Version

use Term::ANSIColor;
use IPC::Open3;

sub initDefaults
{
   $compilerPaths{"gcc"} = "/usr/bin/gcc";
   $compilerPaths{"g++"} = "/usr/bin/g++";
   $compilerPaths{"cc"}  = "/usr/bin/cc";
   $compilerPaths{"c++"} = "/usr/bin/c++";

   $nocolor{"dumb"} = "true";

   $colors{"srcColor"} = color("cyan");
   $colors{"introColor"} = color("white");

   $colors{"warningFileNameColor"} = color("yellow");
   $colors{"warningNumberColor"}   = color("yellow");
   $colors{"warningMessageColor"}  = color("yellow");

   $colors{"errorFileNameColor"} = color("bold red");
   $colors{"errorNumberColor"}   = color("bold red");
   $colors{"errorMessageColor"}  = color("bold red");
}

sub loadPreferences
{
# Usage: loadPreferences("filename");

   my($filename) = @_;

   open(PREFS, "<$filename") || return;

   while(<PREFS>)
   {
      next if (m/^\#.*/);          # It's a comment.
      next if (!m/(.*):\s*(.*)/);  # It's not of the form "foo: bar".

      $option = $1;
      $value = $2;

      if ($option =~ m/cc|c\+\+|gcc|g\+\+/)
      {
	 $compilerPaths{$option} = $value;
      }
      elsif ($option eq "nocolor")
      {
	 # The nocolor option lists terminal types, separated by
	 # spaces, not to do color on.
	 foreach $termtype (split(/\s+/, $value))
	 {
	    $nocolor{$termtype} = "true";
	 }
      }
      else
      {
	 $colors{$option} = color($value);
      }
   }
   close(PREFS);
}

sub srcscan
{
# Usage: srcscan($text, $normalColor)
#    $text -- the text to colorize
#    $normalColor -- The escape sequence to use for non-source text.

# Looks for text between ` and ', and colors it srcColor.

   my($line, $normalColor) = @_;

   my($srcon) = color("reset") . $colors{"srcColor"};
   my($srcoff) = color("reset") . $normalColor;

   $line = $normalColor . $line;

   # This substitute replaces `foo' with `AfooB' where A is the escape
   # sequence that turns on the the desired source color, and B is the
   # escape sequence that returns to $normalColor.
   $line =~ s/\`(.*?)\'/\`$srcon$1$srcoff\'/g;

   print($line, color("reset"));
}

#
# Main program
#

# Set up default values for colors and compilers.
initDefaults();

# Read the configuration file, if there is one.
$configFile = $ENV{"HOME"} . "/.colorgccrc";
if (-f $configFile)
{
   loadPreferences($configFile);
}

# Figure out which compiler to invoke based on our program name.
$0 =~ m%.*/(.*)$%;
$progName = $1 || $0;

$compiler = $compilerPaths{$progName} || $compilerPaths{"gcc"};
$compiler = "gmake";

# Get the terminal type. 
$terminal = $ENV{"TERM"} || "dumb";

# If it's in the list of terminal types not to color, or if
# we're writing to something that's not a tty, don't do color.
if (! -t STDOUT || $nocolor{$terminal})
{
   exec $compiler, @ARGV
      or die("Couldn't exec");
}

# Keep the pid of the compiler process so we can get its return
# code and use that as our return code.
$compiler_pid = open3('<&STDIN', \*GCCOUT, '', $compiler, @ARGV);

# Colorize the output from the compiler.
while(<GCCOUT>)
{
   if (m/^(.*?):([0-9]+):(.*)$/) # filename:lineno:message
   {
      $field1 = $1 || "";
      $field2 = $2 || "";
      $field3 = $3 || "";

      if ($field3 =~ m/\s+warning:.*/)
      {
	 # Warning
	 print($colors{"warningFileNameColor"}, "$field1:", color("reset"));
	 print($colors{"warningNumberColor"}, "$field2:", color("reset"));
	 srcscan($field3, $colors{"warningMessageColor"});
      }
      else 
      {
	 # Error
	 print($colors{"errorFileNameColor"}, "$field1:", color("reset"));
	 print($colors{"errorNumberColor"}, "$field2:", color("reset"));
	 srcscan($field3, $colors{"errorMessageColor"});
      }
      print("\n");
   }
   elsif (m/^(.*?):(.+):$/) # filename:message:
   {
      # No line number, treat as an "introductory" line of text.
      srcscan($_, $colors{"introColor"});
   }
   else # Anything else.        
   {
      # Doesn't seem to be a warning or an error. Print normally.
      print(color("reset"), $_);
   }
}

# Get the return code of the compiler and exit with that.
waitpid($compiler_pid, 0);
exit ($? >> 8);







ct_diff/        1364400864  97975 1054  100751  153       `
cleartool find . -version 'DefectNumber=="'$1'"' -print
cleartool find . -version 'DefectNumber=="'$1'"' -exec 'cleartool diff -pre -gra $CLEARCASE_XPN'

labels/         1364400864  97975 1054  100751  229       `
echo "2012.10.5: 	sp19.2.5.9-py-load	PY19.2.5.9"
echo "2013.0:		sp19.2.7.8-py-load	PY19.2.7.8"
echo "2013.1:		sp19.2.8.0-py-load	PY19.2.8.0"
echo "2013.1.5:		sp19.3.0.2-py-load  	"
echo "2013.2:		sp19.3.1.1-py-load 	PY19.3.1.1"


lsmerges/       1364400864  97975 1054  100751  236       `
#! /bin/sh
for i in `cleartool find . -branch "brtype($1)" -print`
do
	for j in `cleartool lsvtree -s -a -nco -branch /main/$1 $i | egrep "/[1-9][0-9]*$"`
	do
		cleartool describe -fmt '%Nc\t%N[DefectNumber]a\t%Nl\t%n\n' $j
	done
done

my_help/        1364400864  97975 1054  100751  3804      `
#! /bin/csh -f
set t = `stty -a | grep columns| sed -e 's/;//g'`
echo " "

isql -w $t[7] -n -S$SYB_SERVER -U $SYB_USER -P $SYB_PWD <<EOF
use PYR_TRADE
go
        set nocount on
        declare @obj_type varchar(30)
        select @obj_type = so.type
        from sysobjects so
        where   so.name = '$1'

        if @obj_type = 'U' select @obj_type = 'User Table'
        if @obj_type = 'V' select @obj_type = 'View'

        select
                Name=so.name,
                Owner=su.name,
                Type=@obj_type
        from    sysobjects so,
                sysusers su
        where   so.name = '$1'
        and     su.uid = so.uid
go
EOF
echo " "

isql -w $t[7] -n -S$SYB_SERVER -U $SYB_USER -P $SYB_PWD <<EOF | awk '\
{\
        if ($2 == "int") \
	{ \
		printf ("[32m%-30s[0m", $1);\
	} else {\
		if ($2 == "float") \
		{\
			printf ("[31m%-30s[0m", $1); \
		} else {\
			if ($2 == "char") \
			{ \
				printf ("[36m%-30s[0m", $1); \
			} else {\
				printf ("[0m%-30s", $1); \
			}\
		}\
	}\
        printf (" %-15s %-6s %-8s %-7s %s", $2, $3, $4, $5, $6); \
	printf ("\n");\
}'
use PYR_TRADE
go
set nocount on
select  'Column'=sc.name,
        'Type' = convert(char(15), st.name),
        'Length'=sc.length,
        'Nulls'=case when (convert(bit, (sc.status & 8)) = 1) then 'Null'
                 else 'Not_Null'
                 end,
        'Keys'=convert(char(7), sv.name),
        'Related Table'=isnull(so2.name, ' ')
from    syscolumns sc,
        sysobjects so,
        sysobjects so2,
        systypes st,
        syskeys sk,
        master.dbo.spt_values sv
where   so.name = '$1'
and     sc.id = so.id
and     sc.usertype *= st.usertype
and     sc.id = sk.id
and     (sc.name = col_name(sk.id, key1)
        or sc.name = col_name(sk.id, key2)
        or sc.name = col_name(sk.id, key3)
        or sc.name = col_name(sk.id, key4)
        or sc.name = col_name(sk.id, key5)
        or sc.name = col_name(sk.id, key6)
        or sc.name = col_name(sk.id, key7)
        or sc.name = col_name(sk.id, key8))
and     sv.number = sk.type
and     sv.type = 'K'
and     so2.id =* sk.depid
order by sk.type, sc.type, sc.name
go
EOF

isql -w $t[7] -n -S$SYB_SERVER -U $SYB_USER -P $SYB_PWD <<EOF sed -e '1d' -e '2d' | awk '\
{\
        if ($2 == "int") \
	{ \
		printf ("[32m%-30s[0m", $1);\
	} else {\
		if ($2 == "float") \
		{\
			printf ("[31m%-30s[0m", $1); \
		} else {\
			if ($2 == "char") \
			{ \
				printf ("[36m%-30s[0m", $1); \
			} else {\
				printf ("[0m%-30s", $1); \
			}\
		}\
	}\
        printf (" %-15s %-6s %-7s", $2, $3, $4); \
	printf ("\n");\
}'
set nocount on
use PYR_TRADE
go
select  'Column Name'=sc.name,
        'Type' = convert(char(15), st.name),
        'Length'=sc.length,
        'Nulls'=case when (convert(bit, (sc.status & 8)) = 1) then 'Null'
                 else 'Not_Null'
                 end
from    syscolumns sc,
        sysobjects so,
        systypes st
where   so.name = '$1'
and     sc.id = so.id
and     sc.usertype *= st.usertype
and     sc.name not in (select sc.name
                from    syscolumns sc,
                        sysobjects so,
                        syskeys sk
                where   so.name = '$1'
                and     sc.id = so.id
                and     sc.id = sk.id
                and     (sc.name = col_name(sk.id, key1)
                        or sc.name = col_name(sk.id, key2)
                        or sc.name = col_name(sk.id, key3)
                        or sc.name = col_name(sk.id, key4)
                        or sc.name = col_name(sk.id, key5)
                        or sc.name = col_name(sk.id, key6)
                        or sc.name = col_name(sk.id, key7)
                        or sc.name = col_name(sk.id, key8)))
order by st.name, sc.status
go
EOF
echo " "
procroot/       1364400864  97975 1054  100751  1071      `
#! /bin/sh
indent="+- "
if [ $# -gt 1 ]
then
	indent="..$2"
fi
echo ${indent} $1
count=0
proc_count=0
cd /vobs/edg/databases/TRADING/procedures/
methods=`egrep -h EDG_METHOD */$1.sp */$1.sql  2> /dev/null| sed -e 's/^.*=.\"//' -e 's/\".*$//'`
procs=`egrep -h EGW_PROC_NAME */$1.sp */$1.sql  2> /dev/null| sed -e 's/^.*=.\"//' -e 's/\".*$//'`
for i in `egrep -h "[^A-Za-z_]exec[^A-Za-z_]|[^A-Za-z_]EXEC[^A-Za-z_]|^exec |^EXEC " */$1.sql */$1.sp 2> /dev/null| egrep -v "^[ 	]*--|\(\'delete" | sed -e 's/\@[a-zA-Z_]*//g' -e 's/[=,]//g' | awk 'BEGIN { FS = " " } { printf("%s\n", $2) }' 2> /dev/null`
do
	if [ "$i" = "EDG_GATEWAY...EdgMsgPublish" ]
	then
		count=`expr "$count" + 1`
		cmd="{  print  $"
		cmd=${cmd}"$count }"
		/usr/ucb/echo -n ${indent} $i ": "
		method=`echo $methods | awk  "${cmd}"`
		if [ "$method" = "EGW_PROC_NOTIFICATION" ]
		then
			/usr/ucb/echo -n $method ": "
			proc_count=`expr "$proc_count" + 1`
			cmd="{  print  $"
			cmd=${cmd}"$proc_count }"
			echo $procs | awk  "${cmd}"
		else
			echo $method
		fi
	else	
		proctree $i $indent
	fi
done

proctree/       1364400864  97975 1054  100751  1583      `
#! /bin/sh

show_tables="N"
if [ "$1" = "-l" ]
then
	show_tables="Y"
	shift
fi

indent="+- "
tree=$1
if [ $# -gt 1 ]
then
	indent="..$2"
	tree="$3;$1"
fi

#cd /vobs/edg/databases/TRADING/procedures/
cd /vobs/edg/databases/TRADING/procedures/ext_interfaces/pyramid_interfaces

echo ${indent} $1
if [ "$show_tables" = "Y" -a -f */$1.* ]
then
	tbl_indent=`echo $indent | sed -e 's/+-/... /'`
	cmd='{printf("'${tbl_indent}'%s\n", $1)}'
	tablesinprocs */$1.* | awk "${cmd}"
fi

count=0
proc_count=0
methods=`egrep -h EDG_METHOD */$1.sp */$1.sql  2> /dev/null| sed -e 's/^.*=.\"//' -e 's/\".*$//'`
procs=`egrep -h EGW_PROC_NAME */$1.sp */$1.sql  2> /dev/null| sed -e 's/^.*=.\"//' -e 's/\".*$//'`
for i in `egrep -h "[^A-Za-z_]exec[^A-Za-z_]|[^A-Za-z_]EXEC[^A-Za-z_]|^exec |^EXEC " */$1.sql */$1.sp 2> /dev/null| egrep -v "^[ 	]*--|'delete|\[|lib_" | sed -e 's/\@[a-zA-Z_]*//g' -e 's/[=,]//g' | awk 'BEGIN { FS = " " } { printf("%s\n", $2) }' 2> /dev/null`
do
	if [ "$i" = "EDG_GATEWAY...EdgMsgPublish" ]
	then
		count=`expr "$count" + 1`
		cmd="{  print  $"
		cmd=${cmd}"$count }"
		/bin/echo -n ${indent} $i ": "
		method=`echo $methods | awk  "${cmd}"`
		if [ "$method" = "EGW_PROC_NOTIFICATION" ]
		then
			/bin/echo -n $method ": "
			proc_count=`expr "$proc_count" + 1`
			cmd="{  print  $"
			cmd=${cmd}"$proc_count }"
			echo $procs | awk  "${cmd}"
		else
			echo $method
		fi
	else	
		before=`echo $tree|grep $i`
		if [ "$before" != "$tree" ]
		then
			if [ "$show_tables" = "Y" ]
			then
				proctree -l $i $indent $tree
			else
				proctree $i $indent $tree
			fi
		fi
	fi
done

qsplit/         1364400864  97975 1054  100751  1731      `
#!/usr/bin/perl


if ($#ARGV < 0)
{
	@ARGV[0]='-';
}

my $XMLFileName = "";
my $IBMLFileName = "";
my $inMessage="N";
my $fileContents="";
my $msgId = "1";

while (my $lineFromFile = <> )
{
	if ($lineFromFile =~ m/<positionUpdateNotification/)
	{
		$XMLFileName = "";
		$inMessage = "Y";
		$fileContents="";
		$lineFromFile =~ s/  //;
	}
	$fileContents = $fileContents . $lineFromFile;
	if ($lineFromFile =~ m/<\?xml version=\"1.0\" encoding=\"UTF-8\"\?>/)
	{
		if ($inMessage eq "Y")
		{
			$IBMLFileName = $XMLFileName . "_IBML.xml";
		}
		$XMLFileName = "";
		$inMessage = "Y";
	}

	if ($lineFromFile =~ m/<\/quicksilver>/)
	{
		open(XMLOUT, "> " . $XMLFileName . ".xml");
		print XMLOUT $fileContents;
		close(XMLOUT);
		$fileContents="";
	}

	if ($lineFromFile =~ m/<\/positionUpdateNotification>/)
	{
		open(IBMLOUT, "> " . $XMLFileName . ".xml");
		print IBMLOUT $fileContents;
		close(IBMLOUT);
		$inMessage = "N";
		$fileContents="";
	}
	if ($lineFromFile =~ m/<\/FpML>/)
	{
		open(IBMLOUT, "> " . $IBMLFileName);
		print IBMLOUT $fileContents;
		close(IBMLOUT);
		$inMessage = "N";
		$fileContents="";
	}

	if ($lineFromFile =~ m/<id_trd_moss>/ )
	{
		my $fileName = $lineFromFile;
		chomp($fileName);
		$fileName =~ s/^[^>]*>//;
		$fileName =~ s/<[^<]*$//;
		$XMLFileName = $fileName;
	}
	if ($lineFromFile =~ m/<lib:messageId/ )
	{
		my $fileName = $lineFromFile;
		chomp($fileName);
		$fileName =~ s/^[^>]*>//;
		$fileName =~ s/<[^<]*$//;
		$XMLFileName = $msgId;
		$fileContents =~ s/$fileName/$msgId/;
		$msgId = $msgId + 1;
	}
	if ($lineFromFile =~ m/<businessEvent>/ )
	{
		my $fileName = $lineFromFile;
		$fileName =~ s/^[^>]*>//;
		$fileName =~ s/<[^<]*$//;
		$XMLFileName = $XMLFileName . "_" . $fileName;
	}
}

selector/       1364400864  97975 1054  100751  885       `
#!/usr/bin/python

import sys, tty, termios

posssibilities = []
descriptors = []
f = open(sys.argv[1], 'r')
for line in f:
	possibleAction=line.split('|')
	if len(possibleAction) == 1:
		posssibilities.append(possibleAction[0])
		descriptors.append(possibleAction[0])
	else:
		descriptors.append(possibleAction[0] + '\n')
		posssibilities.append(possibleAction[1])

sys.stderr.write("\n")
index = 0
for desc in descriptors:
	if index > 9:
		line = chr(index + 87 ) + ":	" + desc
	else:
		line = str(index) + ":	" + desc
	sys.stderr.write(line)
	index = index + 1

fd = sys.stdin.fileno()
old_settings = termios.tcgetattr(fd) 
tty.setraw(sys.stdin.fileno()) 
ch = sys.stdin.read(1) 
termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)

if ch != "Q":
	index=0
	asc=ord(ch)
	if asc > 96:
		index=asc - 87
	else:
		index=int(ch)
	print posssibilities[index],

sys.stderr.write("\n")



tablesearch/    1364400864  97975 1054  100751  239       `
#! /bin/sh

localDir="./"
if [ $# -gt 1 ]
then
	localDir=$2
fi

cd /vobs/edg/databases/TRADING/procedures/
for i in `ls -F $localDir | grep "/" 2> /dev/null`
do
	egrep -l "$1[^_]" $localDir$i* 2> /dev/null
	tablesearch $1 $localDir$i
done

tablesinprocs/  1364400864  97975 1054  100751  140       `
#! /bin/sh

for i in `cat /home/pyramid/u425970/bin/tables`
do
	search=`egrep -l $i $1`
	if [ "$search" = "$1" ]
	then
		echo $i
	fi
done
	
wgrep/          1364400864  97975 1054  100751  95        `
#! /bin/sh
for i in `cat ~/etc/possible_search_dirs`
do
	echo $i
	cd $i
	grep -i "$1" *.*
done

xmlprint/       1364400864  97975 1054  100751  2774      `
#!/usr/bin/perl

use Term::ANSIColor;

my $cyan;
my $red;
my $green;
my $magenta;
my $blue;
my $reset;

my $commentStart="N";
my $indent="";
my $indentStr="  ";

for ($count = 2; $count >= 1; $count-- )
{
	if ($ARGV[0] eq "-v" || $ARGV[0] eq "-c")
	{
		if ($ARGV[0] eq "-v")
		{
			$indentStr="| ";
		}
		if ($ARGV[0] eq "-c")
		{
			$cyan= color("bold cyan");
			$red= color("bold red");
			$green= color("green");
			$magenta= color("magenta");
			$blue= color("bold blue");
			$reset=color("reset");
		}
		shift @ARGV;
	}
}
if ($#ARGV < 0)
{
	@ARGV[0]='-';
}

while (my $lineFromFile = <> ) 
{
	$lineFromFile =~ s/></>:::</g;
	my @splitLine = split(':::', $lineFromFile);
	foreach my $line (@splitLine) 
	{
		chomp($line);
		my $elementStart = "N";
		my $elementEnd = "N";
		my $commentEnd = "N";
		my $documentStart = "N";
	
		if ($line =~ m/<\?.*\?>/ )
		{
			$documentStart = "Y";
		}
		if ($line =~ m/<!--/ )
		{
			$commentStart = "Y";
		}
		if ($line =~ m/-->/ )
		{
			$commentEnd = "Y";
		}
		if ($line =~ m/<[^\/]/)
		{
			$elementStart = "Y";
		}
		if ($line =~ m/<\/|.*\/>/)
		{
			$elementEnd = "Y";
		}
	
		if ($commentStart eq "Y" || $commentEnd eq "Y")
		{
			if ($commentStart eq "Y" && $commentEnd eq "Y")
			{
				$line =~ s/<!--/$green<!--/;
				$line =~ s/-->/-->$reset/;
				print($indent, $line, "\n");
				$commentStart = "N";
			}
			if ($commentStart eq "Y" && $commentEnd eq "N")
			{
				$line =~ s/^[^<]*</</;
				$line =~ s/<!--/$green<!--/;
				print($indent, $line, "\n");
			}
		}
		else
		{
			if ($documentStart eq "Y")
			{
				$line =~ s/^[^<]*</</;
				$line =~ s/</$blue</;
				$line =~ s/>/>$reset/;
				$line =~ s/("[^"]*")/$red$1$blue/g;
				$line =~ s/(<[A-Za-z]* )/$1$magenta/g;
				$line =~ s/=/$blue=/g;
				print($indent, $line, "\n");
	
			}
			else
			{
				if ($elementStart eq "Y" && $elementEnd eq "Y")
				{
					$line =~ s/^[^<]*</</;
					$line =~ s/</$cyan</g;
					$line =~ s/>/>$reset/g;
					$line =~ s/("[^"]*")/$red$1$cyan/g;
					$line =~ s/(<[A-Za-z]* )/$1$magenta/g;
					$line =~ s/=/$cyan=/g;
					print($indent, $line, "\n");
				
				}
				if ($elementStart eq "Y" && $elementEnd eq "N")
				{
					$line =~ s/^[^<]*</</;
					$line =~ s/</$cyan</g;
					$line =~ s/>/>$reset/g;
					$line =~ s/("[^"]*")/$red$1$cyan/g;
					$line =~ s/(<[A-Za-z]* )/$1$magenta/g;
					$line =~ s/=/$cyan=/g;
					print($indent, $line, "\n");
					$indent = $indent . $indentStr;
				}
				if ($elementStart eq "N" && $elementEnd eq "Y")
				{
					$line =~ s/^[^<]*</</;
					$indent =~ s/^..//;
					$line =~ s/</$cyan</g;
					$line =~ s/>/>$reset/g;
					$line =~ s/("[^"]*")/$red$1$cyan/g;
					$line =~ s/(<[A-Za-z]* )/$1$magenta/g;
					$line =~ s/=/$cyan=/g;
					print($indent, $line, "\n");
				}
			}
		}
	}
}
.colorgccrc/    1213006151  97975 1054  100640  1376      `
#
# colorgcc configuration file
#
# $Id: colorgccrc,v 1.1.1.1 1999/04/25 15:24:03 jamoyers Exp $
#
# This file should be named $HOME/.colorgccrc
#
#
# The following groups of attributes may be combined for a given color:
#
# clear         black      on_black   
# reset	        red        on_red     
# bold	        green      on_green   
# underline     yellow     on_yellow  
# underscore    blue       on_blue    
# blink	        magenta    on_magenta 
# reverse       cyan       on_cyan    
# concealed     white      on_white   
#
# For example, srcColor: bold cyan on_yellow
#

# Define the paths to the actual location of the various compilers.
# (Currently, colorgcc only understands these: g++ gcc c++ cc)
g++: /usr/bin/g++
gcc: /usr/bin/gcc
c++: /usr/bin/c++
cc:  /usr/bin/cc

# Don't do color if our terminal type ($TERM) is one of these.
# (List all terminal types on one line, seperated by whitespace.)
nocolor: dumb

# Text between ` and ' is usually source code.
srcColor: bold cyan

# Text other than a warning or error.
introColor: reset

# Warnings and errors both have similar formats:
#    filename:999:Message
# Each field may be assigned a different color.

# Warnings
warningFileNameColor: reset
warningNumberColor:   white
warningMessageColor:  bold yellow

# Errors
errorFileNameColor: reset
errorNumberColor:   white
errorMessageColor:  bold red




.cshrc_local/   1359382455  97975 1054  100640  4418      `
stty erase 
env| grep VOB

set filec=ESC

test -f /apps/environment/Default.csh && source /apps/environment/Default.csh

source /apps/bin/0LOAD 
Load open_client 
Load clearcase 
#Load espritesitran
#Load corsair
#Load jdk
#Load MQSeries
#Load jConnect
#Load xalan
#Load xerces
#Load SUNWspro

#setenv CLASSPATH /vobs/edg/ext_interfaces/pyr_common_feed/lib/pyr_common_feed.jar:{$CLASSPATH}

alias ct cleartool
alias setview 'cleartool setview amackec_edg'

setenv MANPATH /usr/man:/opt/perl/5.0.0.4/solaris/man:/usr/dt/man:/net/pyrexceed1/export/opt/purelink/2.0.0.0/solaris/man:/opt/purify/4.1.0.0/solaris/man:/usr/atria/doc/man:/net/pyrexceed1/export/opt/SUNWspro/4.2.0.07/solaris/SUNWspro/man:/usr/openwin/man

#DBs
alias SYB 'env | grep SYB_'
alias SUPP_DSPYRNY  'setenv SYB_SERVER SUPP_DSPYRNY; setenv SYB_DB PYR_TRADE;setenv SYB_USER eqdba;setenv SYB_PWD eqdba_12;SYB'
alias DS_EMEA95  'setenv SYB_SERVER DS_EMEA95; setenv SYB_DB PYR_TRADE;setenv SYB_USER eqdba;setenv SYB_PWD SybLinux12;SYB'
alias DS_EMEA39  'setenv SYB_SERVER DS_EMEA39; setenv SYB_DB PYR_TRADE;setenv SYB_USER eqdba;setenv SYB_PWD SybLinux12;SYB'
alias SUPP_DSCHYPYRLN  'setenv SYB_SERVER SUPP_DSCHYPYRLN; setenv SYB_DB PYR_TRADE;setenv SYB_USER eqdba;setenv SYB_PWD SybLinux12;SYB'
alias SUPP_DSPYRLN2  'setenv SYB_SERVER SUPP_DSPYRLN2; setenv SYB_DB PYR_TRADE;setenv SYB_USER eqdba;setenv SYB_PWD SybLinux12;SYB'

alias emea39 'DS_EMEA39'
alias emea95 'DS_EMEA95'
alias chsupp 'SUPP_DSCHYPYRLN'
alias nysupp 'SUPP_DSPYRNY'
alias lnsupp 'SUPP_DSPYRLN2'

alias ds_ny70_feeds 'echo chase321 ; ssh edcmc-pyr6.us.jpmchase.NET -l pyrna069'
alias ds_ny70_pcs 'echo chase321 ; ssh edcmc-pcs2.us.jpmchase.NET -l pyrna070'
alias ds_ny70_eis 'echo chase321 ; ssh eqd-lxapp29 -l pyrem207'
alias ch_dev_pcs 'echo yrem34_p ; ssh ehcl-bas01 -l pyrem341'
alias ch_uat_pcs 'echo yrem40_p ; ssh ehcl-bas01 -l pyrem404'
alias ch_dev_feeds 'echo yrem47_p ; ssh ehd-lxap04 -l pyrem470'
alias pcs_supp_tk 'echo cde34rfv ; ssh ehcl-sly11.sly.hk.jpmorganchase.com -l pyrap06'

alias vob 'cd /vobs/edg/databases/TRADING/procedures'
alias qs 'cd /vobs/edg/databases/TRADING/procedures/ext_interfaces/pyramid_interfaces/quicksilver'
alias prop 'cd /vobs/edg/ext_interfaces/erebus/properties'
alias vk 'cd /home/pyr_users/u063466/docs'
alias diff 'colordiff.pl'

alias vi vim
setenv PATH /opt/CollabNet_Subversion/bin:.:${PATH}:/opt/bin:~/bin:~/akm/bin:/apps/vim/5.4.0.0/solaris/bin:~/dbs:$VOB_EDG_ROOT/database/bin:/home/chpyr_dev/pyrchd66/apache-maven-2.2.1/bin

#if (! -d /vobs/edg/databases) cleartool setview amackec_edg
if (! $?SYB_SERVER) then
        DSEQ_GENLN18
endif
source ~/akm/.cshrc
alias stc cleartool setview u425970_edg
setenv PYR_LOG_FILES /home/pyr_uat/pyrem404/PYRAMID/ds_emea39_chln/logs

alias wcd 'cd `~/bin/selector ~/etc/possible_dirs`'
#alias wcd 'set dir=`~/bin/wcd` ; if ( ${#dir} != 0 )  cd $dir'
alias wssh '`~/bin/selector ~/etc/possible_envs`'
alias wdb 'source `~/bin/selector ~/etc/possible_dbs`; SYB'
alias wsetcs 'ct setcs `~/bin/selector ~/etc/possible_specs`'

alias addir 'echo $cwd >> $HOME/etc/possible_dirs; sort <$HOME/etc/possible_dirs >$HOME/etc/possible_dirs2; mv -f $HOME/etc/possible_dirs2 $HOME/etc/possible_dirs;'

stty erase 

#
# SLAB related
#
if ( -r /deploy/DEV/etc/slab_security_domain_profile.csh ) then
   source /deploy/DEV/etc/slab_security_domain_profile.csh  

   # Comment these in to set env grp and env as default.
   #
   # source /usr/local/slab/scripts/slab_setenvgrp.csh PYREQ
   # source /usr/local/slab/scripts/slab_setenv.csh PYREQ.dev01

   # Show SLAB setup status
   chkslab  
   echo "To set environment group : slab_setenvgrp PYREQ"
   echo "To set environment : slab_setenv PYREQ.dev01"
   echo "To check SLAB vars : chkslab"  
   echo "------------------------------------------------------"
   echo "Useful directories:"
   echo -n "cd $SLAB_ROOT/$SECURITY_DOMAIN/env/"
   if ( $?ENVGRP ) then
      echo -n "$ENVGRP/"
   endif
   if ( $?DB_ENV ) then
      echo -n "$DB_ENV/"
   endif
   echo;echo "cd $SLAB_ROOT/$SECURITY_DOMAIN/pkgs/PYR/development";echo
endif

setenv PYR_REP_TODAY $HOME/PYRAMID/out
alias mvn_build "mvn clean -Dmaven.test.skip=true assembly:assembly"

#setenv pts `ps -f | grep $LOGNAME | grep -v TTY | awk '{print $6}' | uniq`
#setenv display `who -u | grep $LOGNAME | grep $pts | awk -F"(" '{print $2}' | awk -F")" '{print $1}'`
#setenv DISPLAY ${display}:0.0

.exrc/          1315476888  97975 1054  100644  799       `
set showmode showmatch 
set ic
set scs
" 
" automatic spelling checker
"
map v :w:$r!spell -b %
"
" Automatic make
"
map  :w:!/usr/local/bin/make dbx; echo ""
" map *  "syy!s grep
" set tabstop=4
so $HOME/vim/myfiletypes.vim
syntax on
highlight Comment ctermfg=DarkGreen guifg=DarkGreen term=bold
" Groups for syntax highlighting
highlight Constant ctermfg=Magenta guifg=Magenta guibg=grey5
highlight Special ctermfg=Cyan guifg=Cyan guibg=Red
highlight Statement cterm=bold ctermfg=Cyan guifg=Cyan gui=bold
highlight Type cterm=bold ctermfg=Cyan guifg=Cyan gui=bold
highlight Directory ctermfg=Yellow guifg=Yellow guibg=Yellow
highlight SpecialKey ctermfg=Yellow guifg=Yellow guibg=Yellow
highlight Error ctermfg=Red guifg=Red guibg=Red
highlight shShellVariables ctermfg=Yellow guifg=Yellow

.gvimrc/        1235731999  97975 1054  100640  28        `

 $HOME/vim/myfiletypes.vim
